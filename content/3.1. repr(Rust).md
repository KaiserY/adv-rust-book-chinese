# repr(Rust)

首先和最重要的，所有的类型都有一个基于字节的对齐方式。一个类型的对齐方式指定了储存值的有效地址。一个`n`字节对齐的值必须储存在`n`倍数的地址上。所以2对齐的意味着你必须储存在偶数地址，而1则表示你可以随便存哪里。对齐值最少是1（字节），并总是2的幂（2, 4, 8...）。大多数原始类型通常以它们的大小对齐，尽管这是平台相关的行为。特别的，在x86平台上`u64`和`f64`可能只能以32位对齐。

一个类型的大小必须总是它对齐值的倍数。这保证了一个这个类型的数组总是可以通过位移乘以它的大小来索引。注意在[动态大小类型](https://doc.rust-lang.org/nightly/adv-book/exotic-sizes.html#dynamically-sized-types-(dsts))情况下大小和对齐值可能不能静态的获取到。

Rust给出如下方式来布局复合类型：

* 结构体（命名product type）
* 元组（匿名product type）
* 数组（同质product type）
* 枚举（命名集合类型 -- 标记的联合）

一个枚举在没有一个变量有关联数据时被认为与C语言相似的。

复合结构将拥有一个等于它的字段最大对齐值的对齐值。因此Rust将会在必要时插入填充来保证所有字段正确的对齐和整体的类型大小是它对齐值的倍数。例如：

```rust
struct A {
    a: u8,
    b: u32,
    c: u16,
}
```

将是32位对齐的，假设这些原始类型都对齐到他们的大小。因此它的大小将是32位的倍数。潜在的它真正的样子将是：

```rust
struct A {
    a: u8,
    _pad1: [u8; 3], // to align `b`
    b: u32,
    c: u16,
    _pad2: [u8; 2], // to make overall size multiple of 4
}
```

这些
