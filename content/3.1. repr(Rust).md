# repr(Rust)

首先和最重要的，所有的类型都有一个基于字节的对齐方式。一个类型的对齐方式指定了储存值的有效地址。一个`n`字节对齐的值必须储存在`n`倍数的地址上。所以2对齐的意味着你必须储存在偶数地址，而1则表示你可以随便存哪里。对齐值最少是1（字节），并总是2的幂（2, 4, 8...）。大多数原始类型通常以它们的大小对齐，尽管这是平台相关的行为。特别的，在x86平台上`u64`和`f64`可能只能以32位对齐。

一个类型的大小必须总是它对齐值的倍数。这保证了一个这个类型的数组总是可以通过位移乘以它的大小来索引。注意在[动态大小类型](https://doc.rust-lang.org/nightly/adv-book/exotic-sizes.html#dynamically-sized-types-(dsts))情况下大小和对齐值可能不能静态的获取到。

Rust给出如下方式来布局复合类型：

* 结构体（命名product type）
* 元组（匿名product type）
* 数组（同质product type）
* 枚举（命名集合类型 -- 标记的联合）

一个枚举在没有一个变量有关联数据时被认为与C语言相似的。

复合结构将拥有一个等于它的字段最大对齐值的对齐值。因此Rust将会在必要时插入填充来保证所有字段正确的对齐和整体的类型大小是它对齐值的倍数。例如：

```rust
struct A {
    a: u8,
    b: u32,
    c: u16,
}
```

将是32位对齐的，假设这些原始类型都对齐到他们的大小。因此它的大小将是32位的倍数。潜在的它真正的样子将是：

```rust
struct A {
    a: u8,
    _pad1: [u8; 3], // to align `b`
    b: u32,
    c: u16,
    _pad2: [u8; 2], // to make overall size multiple of 4
}
```

这些类型之间没有*间隔*；所有数据都是连续储存的，正如你在C语言里期待的那样。然而数组是一个例外（它们是紧密打包并连续的），数据的布局默认并不由Rust指定。给定如下两个结构体定义：

```rust
struct A {
    a: i32,
    b: u64,
}

struct B {
    x: i32,
    b: u64,
}
```

Rust*确实*保证两个A的实例有确实相同的数据布局。然而Rust*并不*保证一个A的实例和一个B的实例有相同字段顺序或填充（在实践中并没有特别的理由为什么它们不一样，除了目前它没有被保证）。

A和B写成这样，这基本上是无意义的，不过其他一些Rust的功能使得语言处理数据布局变得很理想，以一种复杂的方式。

例如，考虑这个结构体：

```rust
struct Foo<T, U> {
    count: u16,
    data1: T,
    data2: U,
}
```

