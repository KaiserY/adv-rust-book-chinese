# 特殊大小类型
多数时候我们认为类型有一个固定的正的大小。然而并不总是这样。

## 动态大小类型（Dynamically Sized Types (DSTs)）
事实上Rust支持动态大小类型（DSTs）：没有一个已知的大小或对齐值的类型。表面上这有点荒谬：Rust*必须*知道大小和对齐什么的才能正常处理它们！在这一点上，DST并不是正常的类型。因为他们缺乏静态可知的大小，这些类型只能存在于一些指针之后。任何指向DST的指针也因此变成了一个*胖*指针，它包含指针和使其“完整”的信息（下面介绍更多细节）。

语言提供了两个主要的DST：trait对象和切片（slice）。

一个trait对象表现为一些实现了它指定trait的类型。它实际的原始类型被一个包含使用这个类型所需的所有信息的虚函数表（vtable）所*清除*，通过动态反射的支持。这就是一个trait对象的完整信息：一个它的vtable的指针。

切片仅仅是一些连续储存的一个视图 -- 代表性的有数组或`Vec`。一个切片的完整信息仅仅是它指向的元素的数量。

事实上结构体可以在他们的最后一个字段上存储一个单独的DST，不过这也使得它变成了一个DST：

```rust
// Can't be stored on the stack directly
struct Foo {
    info: u32,
    data: [u8],
}
```

**注意：[Rust 1.0中，如果结构体DST的最后一个字段有一个基于它的对齐的可变位置则会出错](https://github.com/rust-lang/rust/issues/26403)**

## 0大小类型（Zero Sized Types (ZSTs)）
Rust也允许指定不占用空间的类型：

```rust
struct Foo; // No fields = no size

// All fields have no size = no size
struct Baz {
    foo: Foo,
    qux: (),      // empty tuple has no size
    baz: [u8; 0], // empty array has no size
}
```

很明显，仅就ZST本身而言，是非常没有用的。然而，
