# 特殊大小类型
多数时候我们认为类型有一个固定的正的大小。然而并不总是这样。

## 动态大小类型（Dynamically Sized Types (DSTs)）
事实上Rust支持动态大小类型（DSTs）：没有一个已知的大小或对齐值的类型。表面上这有点荒谬：Rust*必须*知道大小和对齐什么的才能正常处理它们！在这一点上，DST并不是正常的类型。因为他们缺乏静态可知的大小，这些类型只能存在于一些指针之后。任何指向DST的指针也因此变成了一个*胖*指针，它包含指针和使其“完整”的信息（下面介绍更多细节）。

语言提供了两个主要的DST：trait对象和切片（slice）。

一个trait对象表现为一些实现了它指定trait的类型。它实际的原始类型被一个包含使用这个类型所需的所有信息的虚函数表（vtable）所*清除*，通过动态反射的支持。这就是一个trait对象的完整信息：一个它的vtable的指针。

切片仅仅是一些连续储存的一个视图 -- 代表性的有数组或`Vec`。一个切片的完整信息仅仅是它指向的元素的数量。

事实上结构体可以在他们的最后一个字段上存储一个单独的DST，不过这也使得它变成了一个DST：

```rust
// Can't be stored on the stack directly
struct Foo {
    info: u32,
    data: [u8],
}
```

**注意：[Rust 1.0中，如果结构体DST的最后一个字段有一个基于它的对齐的可变位置则会出错](https://github.com/rust-lang/rust/issues/26403)**

## 零大小类型（Zero Sized Types (ZSTs)）
Rust也允许指定不占用空间的类型：

```rust
struct Foo; // No fields = no size

// All fields have no size = no size
struct Baz {
    foo: Foo,
    qux: (),      // empty tuple has no size
    baz: [u8; 0], // empty array has no size
}
```

很明显，仅就ZST本身而言，是非常没有用的。然而就如同Rust中很多稀奇的布局选择一样：它的潜力在泛型环境中得以展现：Rust大体上理解人额好产生和存储ZST的操作可以被缩减为一个no-op。首先，存储它甚至就没有意义 -- 它并不占用任何空间。另外这个类型就只有一个值（0？），所以任何读取它的操作只会凭空产生（从aether中。。。） -- 这也是一个no-op因为它不占有空间。

其中最极端的例子是当他们是Map和Set。给定一个`Map<Key, Value>`，对`Map<Key, UselessJunk>`实现一个
