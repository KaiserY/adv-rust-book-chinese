# 安全与不安全如何交互

那么，那么安全Rust与不安全Rust是什么关系？它们又如何交互？

Rust用`unsafe`关键字来模式化安全与不安全Rust的分别，它可以被理解为一种安全与不安全Rust之间的外部函数接口（FFI）。这是为何我们能够说安全Rust是一个安全语言背后的魔术：就像*其它每一个安全语言*那样，所有可怕的不安全部分都*专门*归类到了FFI中。

然而因为一个语言（安全Rust）是另一个语言（不安全Rust）的一个子集，只要安全与不安全Rust之间的边界使用`unsafe`关键字表示，这两者就可以有规则的混合。不需要写头文件，初始化运行时，或者任何其它FFI模板。

这是目前Rust中`unsafe`可以出现的地方，它们大体上可以分为两类：

* 当这里有未检查的协议时。为了表明你理解了它，我们要求你在这些地方使用`unsafe`：
  * 对于函数，`unsafe`表明函数调用时不安全的。函数的用户必须检查文档来确定它的意义，并必须使用`unsafe`来表明他们意识到了危险。
  * 对于trait声明，`unsafe`表明*实现*这个trait是一个不安全操作，因为它包含其它不安全代码可以盲目信任的协议。（接下来介绍更多。）
* 当我表明，据我所知，我坚持了未检查的协议：
  * 对于trait实现，`unsafe`表明`unsafe`trait包含的协议。
  * 对于代码块，`unsafe`表明一个不安全操作多包含的任何不安全性将被处理，并且因此父函数是安全的。

也有一个`#[unsafe_no_drop_flag]`，它是一个因为历史原因而存在的特例，并且正在被逐步淘汰的过程中。查看[丢弃的标记（drop flags）](https://doc.rust-lang.org/nightly/adv-book/drop-flags.html)章节来获得更多细节。

一些不安全函数的例子：

* `slice::get_unchecked`进行未检查的索引，允许内存安全被随意违反。
* 
